<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid black;
        }

        .controls {
            margin-top: 10px;
        }

        .matrix-selector {
            margin-top: 10px;
        }

        .transformation-box {
            width: 600px;
        }

        .resize-anchor {
            width: 10px;
            height: 10px;
            background-color: grey;
            position: absolute;
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #eraserButton.active {
            background-color: #888;
            color: white;
        }

        #color.disabled {
            background-image: linear-gradient(45deg, #888 25%, transparent 25%, transparent 50%, #888 50%, #888 75%, transparent 75%);
            background-size: 4px 4px;
            opacity: 0.5;
        }

    </style>
</head>
<body>

<div class="canvas-container">
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <div class="resize-anchor" id="resizeAnchor"></div>
</div>

<div class="controls">
    <button id="clearButton">Effacer</button>
    <button id="clearAllButton">Tout effacer</button>
    <button id="addMatrixButton">Ajouter</button>
    <button id="removeMatrixButton">Supprimer</button>
    <select id="matrixSelector" class="matrix-selector"></select>
    <button id="playPauseButton">Play</button>
    <label for="size">Taille du pinceau:</label>
    <input type="range" id="size" min="5" max="500" value="15">
    <label for="color">Couleur du pinceau:</label>
    <button id="eraserButton">üßΩ Gomme</button>
    <input type="color" id="color" value="#ff0000">
    <label for="shape">Forme du pinceau:</label>
    <select id="shape">
        <option value="circle">Cercle</option>
        <option value="square">Carr√©</option>
        <option value="triangle">Triangle</option>
        <option value="segment">Segment</option>
    </select>
    <label for="drawOnDrag">Dessin continu</label>
    <input type="checkbox" id="drawOnDrag">
    <label for="transformationSelector">Fonctions de transformation pr√©d√©finies:</label>
    <select id="transformationSelector">
        <option value="">--S√©lectionner une fonction--</option>
    </select>
    <div id="errorDisplay" style="color: red; margin-top: 10px;"></div>
</div>

<textarea id="transformationCode" class="transformation-box" rows="8">
x = x + 1;
y = y + 1;
</textarea>

<script>
  // Liste des transformations pr√©d√©finies
  const predefinedTransformations = [
    {
      name: 'aide',
      code: `
var index = (y * width + x) * 4;
var otherMatrixIndex = 1; // Indice de la matrice avec laquelle fusionner
var otherRed = matrices[otherMatrixIndex].data[index];
var otherGreen = matrices[otherMatrixIndex].data[index + 1];
var otherBlue = matrices[otherMatrixIndex].data[index + 2];

// Fusion des couleurs
var factor = 0.5; // Facteur de m√©lange
var currentRed = matrices[0].data[index];
matrices[0].data[index] = currentRed * (1 - factor) + otherRed * factor;


var index = (y * width + x) * 4;
var displacementMatrixIndex = 1; // Indice de la matrice de d√©placement
var displacement = matrices[displacementMatrixIndex].data[index] / 255;

x = x + displacement * 10;
y = y + displacement * 10;

      `
    },
    {
      name: 'D√©formation sinus',
      code: `x = x + 3 * Math.sin(2 * Math.PI * y / 100);
y = y + 3 * Math.cos(2 * Math.PI * x / 100);`
    },
    {
      name: 'D√©placement',
      code: `x = x + 1;
y = y + 1;`
    },
    {
      name: 'effet de vibration',
      code: 'x = x + Math.sin(Date.now() / 100) * 5;' +
        'y = y + Math.cos(Date.now() / 100) * 5;'
    },
    {
      name: 'Vagues sinuso√Ødales',
      code: `x = x + Math.sin(y / 10);
y = y + Math.cos(x / 10);`
    },
    {
      name: 'Tourbillon',
      code: `var centerX = width / 2;
var centerY = height / 2;
var angle = Math.PI / 180;
var dx = x - centerX;
var dy = y - centerY;
x = centerX + dx * Math.cos(angle) - dy * Math.sin(angle);
y = centerY + dx * Math.sin(angle) + dy * Math.cos(angle);`
    },
    {
      name: 'Jitter al√©atoire',
      code: `x = x + (Math.random() - 0.5) * 10;
y = y + (Math.random() - 0.5) * 10;`
    },
    {
      name: 'Effet miroir',
      code: `x = width - x;
y = y;`
    },
    {
      name: 'Zoom progressif',
      code: `x = x * 1.01;
y = y * 1.01;`
    },
    {
      name: 'Ondes circulaires',
      code: `var dx = x - width / 2;
var dy = y - height / 2;
var distance = Math.sqrt(dx * dx + dy * dy);
x = x + Math.sin(distance / 10) * 5;
y = y + Math.cos(distance / 10) * 5;`
    },
    {
      name: 'Rotation',
      code: `var angle = Math.PI / 180;
var newX = Math.cos(angle) * x - Math.sin(angle) * y;
var newY = Math.sin(angle) * x + Math.cos(angle) * y;
x = newX;
y = newY;`
    },
    {
      name: 'D√©formation en spirale',
      code: `var angle = Math.atan2(y - height / 2, x - width / 2);
var radius = Math.hypot(x - width / 2, y - height / 2);
angle += radius / 100;
x = width / 2 + radius * Math.cos(angle);
y = height / 2 + radius * Math.sin(angle);`
    },
    {
      name: 'D√©placement vertical',
      code: `x = x;
y = y + Math.sin(x / 20) * 10;`
    },
    {
      name: '√âclatement',
      code: `var centerX = width / 2;
var centerY = height / 2;
x = x + (x - centerX) * 0.01;
y = y + (y - centerY) * 0.01;`
    }
  ];

  class UI {
    constructor() {
      this.clearButton = document.getElementById('clearButton');
      this.clearAllButton = document.getElementById('clearAllButton');
      this.eraserButton = document.getElementById('eraserButton');
      this.pointColorInput = document.getElementById('color');
      this.pointSizeInput = document.getElementById('size');
      this.pointShapeInput = document.getElementById('shape');
      this.drawOnDragCheckbox = document.getElementById('drawOnDrag');
      this.canvas = document.getElementById('myCanvas');
      this.resizeAnchor = document.getElementById("resizeAnchor");
      this.addMatrixButton = document.getElementById("addMatrixButton");
      this.removeMatrixButton = document.getElementById("removeMatrixButton");
      this.matrixSelector = document.getElementById("matrixSelector");
      this.transformationCodeInput = document.getElementById("transformationCode");
      this.playPauseButton = document.getElementById('playPauseButton');
      this.errorDisplay = document.getElementById('errorDisplay');
      this.transformationSelector = document.getElementById('transformationSelector');
    }
  }

  class State {
    constructor() {
      this.currentMatrixIndex = 0;
    }
  }

  class Matrix {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.offscreenCanvas = document.createElement('canvas');
      this.offscreenCanvas.width = width;
      this.offscreenCanvas.height = height;
      this.offscreenCanvasContext = this.offscreenCanvas.getContext('2d');
      this.imageData = this.offscreenCanvasContext.createImageData(this.width, this.height);
    }

    transform(transformationFunction) {
      const newData = new Uint8ClampedArray(this.imageData.data.length);
      const width = this.width;
      const height = this.height;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = (y * width + x) * 4;
          const { x: newX, y: newY } = transformationFunction(x, y);
          const intNewX = Math.floor(newX);
          const intNewY = Math.floor(newY);
          const wrappedX = ((intNewX % width) + width) % width;
          const wrappedY = ((intNewY % height) + height) % height;
          const newIndex = (wrappedY * width + wrappedX) * 4;

          newData[newIndex] = this.imageData.data[index];
          newData[newIndex + 1] = this.imageData.data[index + 1];
          newData[newIndex + 2] = this.imageData.data[index + 2];
          newData[newIndex + 3] = this.imageData.data[index + 3];
        }
      }

      this.imageData.data.set(newData);
      this.offscreenCanvasContext.putImageData(this.imageData, 0, 0);
    }

    drawTo(canvasContext) {
      canvasContext.drawImage(this.offscreenCanvas, 0, 0);
    }

    clear() {
      // Clear the imageData by setting all pixels to transparent
      this.imageData.data.fill(0);
      this.offscreenCanvasContext.putImageData(this.imageData, 0, 0);
    }

    hexToRGBA(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255,
        a: 255 // Full opacity
      };
    }

    paint(x, y, brush) {
      const isEraser = brush.color === null;
      const color = isEraser
        ? { r: 0, g: 0, b: 0, a: 0 }  // Transparent color for eraser
        : this.hexToRGBA(brush.color);

      const halfSize = Math.floor(brush.size / 2);

      if (brush.shape === 'segment' && brush.endX !== undefined && brush.endY !== undefined) {
        this.paintSegment(brush.startX, brush.startY, brush.endX, brush.endY, color, brush.size);
      } else if (brush.shape === 'circle') {
        this.paintCircle(x, y, halfSize, color);
      } else if (brush.shape === 'square') {
        this.paintSquare(x, y, halfSize, color);
      } else if (brush.shape === 'triangle') {
        this.paintTriangle(x, y, halfSize, color);
      }

      // Update the offscreen canvas
      this.offscreenCanvasContext.putImageData(this.imageData, 0, 0);
    }

    paintCircle(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          if (Math.sqrt(offsetX ** 2 + offsetY ** 2) <= halfSize) {
            this.setPixelColor(x + offsetX, y + offsetY, color);
          }
        }
      }
    }

    paintSquare(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          this.setPixelColor(x + offsetX, y + offsetY, color);
        }
      }
    }

    paintTriangle(x, y, halfSize, color) {
      for (let offsetY = 0; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -offsetY; offsetX <= offsetY; offsetX++) {
          this.setPixelColor(x + offsetX, y - offsetY + halfSize, color);
        }
      }
    }

    paintSegment(x1, y1, x2, y2, color, brushSize) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = x1 < x2 ? 1 : -1;
      const sy = y1 < y2 ? 1 : -1;
      let err = dx - dy;
      const halfSize = Math.floor(brushSize / 2);

      while (true) {
        for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
          for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
            this.setPixelColor(x1 + offsetX, y1 + offsetY, color);
          }
        }
        if (x1 === x2 && y1 === y2) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    wrapCoordinate(value, max) {
      return ((value % max) + max) % max;
    }

    setPixelColor(rawX, rawY, color) {
      const x = this.wrapCoordinate(rawX, this.width);
      const y = this.wrapCoordinate(rawY, this.height);
      const index = (y * this.width + x) * 4;

      // Update imageData.data directly
      this.imageData.data[index] = color.r;
      this.imageData.data[index + 1] = color.g;
      this.imageData.data[index + 2] = color.b;
      this.imageData.data[index + 3] = color.a;
    }

    resize(width, height) {
      const newImageData = this.offscreenCanvasContext.createImageData(width, height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const newIndex = (y * width + x) * 4;
          const oldX = x % this.width;
          const oldY = y % this.height;
          const oldIndex = (oldY * this.width + oldX) * 4;

          newImageData.data[newIndex] = this.imageData.data[oldIndex];
          newImageData.data[newIndex + 1] = this.imageData.data[oldIndex + 1];
          newImageData.data[newIndex + 2] = this.imageData.data[oldIndex + 2];
          newImageData.data[newIndex + 3] = this.imageData.data[oldIndex + 3];
        }
      }
      this.width = width;
      this.height = height;
      this.imageData = newImageData;
      this.offscreenCanvas.width = width;
      this.offscreenCanvas.height = height;
      this.offscreenCanvasContext.putImageData(this.imageData, 0, 0);
    }
  }

  class CanvasManager {
    constructor(state, transformationManager, ui) {
      this.state = state;
      this.ui = ui;
      this.canvasContext = this.ui.canvas.getContext('2d');
      this.transformationManager = transformationManager;
      this.brush = { size: 15, color: '#ff0000', shape: 'circle' };
      this.startPoint = null;
      this.matrices = [];

      this.initializeControls();
      this.updateMatrixSelector();
      this.addNewMatrix();

      this.drawOnDrag = this.ui.drawOnDragCheckbox.checked;
    }

    get currentMatrix() {
      return this.matrices[this.currentMatrixIndex];
    }

    get currentMatrixIndex() {
      return this.state.currentMatrixIndex;
    }

    set currentMatrixIndex(index) {
      this.state.currentMatrixIndex = index;
    }

    addNewMatrix() {
      const newMatrix = new Matrix(this.ui.canvas.width, this.ui.canvas.height);
      this.matrices.push(newMatrix);
      this.currentMatrixIndex = this.matrices.length - 1;

      const initialCode = this.transformationManager.getCode(this.currentMatrixIndex);
      this.transformationManager.transformationCodeChanged(this.currentMatrixIndex, initialCode);

      this.updateMatrixSelector();
    }

    removeCurrentMatrix() {
      if (this.matrices.length > 1) {
        this.matrices.splice(this.currentMatrixIndex, 1);
        this.currentMatrixIndex = Math.max(0, this.currentMatrixIndex - 1);
        this.updateMatrixSelector();
        this.updateCanvas();
      }
    }

    initializeControls() {
      this.initClearButton();
      this.initClearAllButton();
      this.initEraserButton();
      this.initBrushSettings();
      this.initDrawOnDragCheckbox();
      this.initCanvasMouseEvents();
      this.initResize();
      this.initMatrixControls();
    }

    initClearButton() {
      this.ui.clearButton.addEventListener('click', () => this.clearCurrentMatrix());
    }

    initClearAllButton() {
      this.ui.clearAllButton.addEventListener('click', () => this.clearAllMatrices());
    }

    initEraserButton() {
      this.ui.eraserButton.addEventListener('click', () => {
        const isEraserActive = this.ui.eraserButton.classList.toggle("active");
        this.brush.color = isEraserActive ? null : this.ui.pointColorInput.value;
        this.ui.pointColorInput.classList.toggle("disabled", isEraserActive);
      });

      // D√©sactive la gomme en r√©tablissant la couleur lorsque l‚Äôutilisateur clique sur le s√©lecteur de couleur
      this.ui.pointColorInput.addEventListener('click', () => {
        this.ui.eraserButton.classList.remove("active");
        this.ui.pointColorInput.classList.remove("disabled");
        this.brush.color = this.ui.pointColorInput.value; // R√©tablit la couleur
      });
    }

    initBrushSettings() {
      this.ui.pointSizeInput.addEventListener('input', () => {
        this.brush.size = parseInt(this.ui.pointSizeInput.value, 10);
      });

      this.ui.pointColorInput.addEventListener('input', () => {
        this.brush.color = this.ui.pointColorInput.value;
      });

      this.ui.pointShapeInput.addEventListener('change', () => {
        this.brush.shape = this.ui.pointShapeInput.value;
      });
    }

    initDrawOnDragCheckbox() {
      this.ui.drawOnDragCheckbox.addEventListener('change', () => {
        this.drawOnDrag = this.ui.drawOnDragCheckbox.checked;
      });
    }

    initResize() {
      const addListeners = () => {
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", removeListeners);
      }
      const removeListeners = () => {
        document.removeEventListener("mousemove", mouseMove);
        document.removeEventListener("mouseup", removeListeners);
      }
      const mouseMove = (event) => {
        const newWidth = Math.ceil(event.clientX - this.ui.canvas.getBoundingClientRect().left);
        const newHeight = Math.ceil(event.clientY - this.ui.canvas.getBoundingClientRect().top);
        this.resizeCanvas(newWidth, newHeight);
      }

      this.ui.resizeAnchor.addEventListener("mousedown", addListeners);
    }

    initMatrixControls() {
      this.ui.addMatrixButton.addEventListener("click", () => this.addNewMatrix());

      this.ui.removeMatrixButton.addEventListener("click", () => this.removeCurrentMatrix());

      this.ui.matrixSelector.addEventListener("change", (event) => {
        this.currentMatrixIndex = parseInt(event.target.value, 10);
        this.updateCanvas();
        this.updateTransformationCodeInput();
      });
    }

    initCanvasMouseEvents() {
      this.ui.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    }

    handleMouseDown(event) {
      const rect = this.ui.canvas.getBoundingClientRect();
      const x = Math.floor(event.clientX - rect.left);
      const y = Math.floor(event.clientY - rect.top);
      this.lastMousePosition = { x, y };
      if (this.brush.shape === 'segment') {
        this.startPoint = { x, y };
      } else {
        this.drawAt(x, y, this.brush);
      }

      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    }

    handleMouseMove = (event) => {
      const rect = this.ui.canvas.getBoundingClientRect();
      const x = Math.floor(event.clientX - rect.left);
      const y = Math.floor(event.clientY - rect.top);
      if (this.drawOnDrag && this.brush.shape !== 'segment') {
        this.lastMousePosition = { x, y };
        this.drawAt(x, y, this.brush);
      } else {
        // For segment drawing, update the end point
        if (this.brush.shape === 'segment' && this.startPoint) {
          this.lastMousePosition = { x, y };
        }
      }
    }

    handleMouseUp = (event) => {
      const rect = this.ui.canvas.getBoundingClientRect();
      const x = Math.floor(event.clientX - rect.left);
      const y = Math.floor(event.clientY - rect.top);

      if (this.brush.shape === 'segment' && this.startPoint) {
        this.brush.startX = this.startPoint.x;
        this.brush.startY = this.startPoint.y;
        this.brush.endX = x;
        this.brush.endY = y;
        this.drawAt(x, y, { ...this.brush });
        this.startPoint = null;
      }
      this.lastMousePosition = null;

      // Remove global listeners
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    clearCurrentMatrix() {
      this.currentMatrix.clear();
      this.updateCanvas();
    }

    clearAllMatrices() {
      this.matrices.forEach(matrix => matrix.clear());
      this.updateCanvas();
    }

    drawAt(x, y, brush) {
      this.currentMatrix.paint(x, y, brush);
      this.updateCanvas();
    }

    updateCanvas() {
      this.canvasContext.clearRect(0, 0, this.ui.canvas.width, this.ui.canvas.height);
      this.matrices.forEach(matrix => matrix.drawTo(this.canvasContext));
    }

    resizeCanvas(newWidth, newHeight) {
      this.ui.canvas.width = newWidth;
      this.ui.canvas.height = newHeight;
      this.matrices.forEach(matrix => matrix.resize(newWidth, newHeight));
      this.updateCanvas();
    }

    updateMatrixSelector() {
      this.ui.matrixSelector.innerHTML = '';
      this.matrices.forEach((_, index) => {
        const option = document.createElement("option");
        option.value = index;
        option.textContent = `Calque ${index + 1}`;
        if (index === this.currentMatrixIndex) option.selected = true;
        this.ui.matrixSelector.appendChild(option);
      });

      this.updateTransformationCodeInput();
      this.ui.errorDisplay.textContent = '';
    }

    drawOnDragInterval() {
      if (this.drawOnDrag && this.lastMousePosition) {
        const { x, y } = this.lastMousePosition;
        this.currentMatrix.paint(x, y, this.brush);
      }
    }

    updateTransformationCodeInput() {
      this.ui.transformationCodeInput.value = this.transformationManager.getCode(this.currentMatrixIndex);
      this.ui.errorDisplay.textContent = '';
    }
  }

  class TransformationManager {
    constructor(state, ui) {
      this.state = state;
      this.ui = ui;
      this.transformationFunctions = {}; // Store transformation functions per matrix
      this.codes = {}; // Store transformation code per matrix
      this.ui.transformationCodeInput.addEventListener('blur', () => this.transformationCodeChanged(this.state.currentMatrixIndex));
    }

    transformationCodeChanged(matrixIndex, code = this.ui.transformationCodeInput.value) {
      this.codes[matrixIndex] = code;
      this.createTransformationFunction(matrixIndex, code);
    }

    getCode(matrixIndex) {
      return this.codes[matrixIndex] || 'x = x + 1;\ny = y + 1;';
    }

    createTransformationFunction(matrixIndex, code) {
      try {
        this.transformationFunctions[matrixIndex] = new Function('x', 'y', 'width', 'height', 'matrices', `${code} return { x, y };`);
        this.ui.errorDisplay.textContent = '';
      } catch (error) {
        this.ui.errorDisplay.textContent = `Erreur dans la fonction de transformation : ${error.message}`;
        console.error("Erreur dans la fonction de transformation : ", error);
        this.transformationFunctions[matrixIndex] = (x, y) => ({ x, y });
      }
    }

    getTransformationFunction(matrixIndex) {
      return this.transformationFunctions[matrixIndex] || ((x, y, _width, _height, _matrices) => ({ x, y }));
    }
  }

  class ControlPanel {
    constructor(canvasManager, transformationManager, ui) {
      this.canvasManager = canvasManager;
      this.transformationManager = transformationManager;
      this.ui = ui;
      this.isPlaying = false;
      this.ui.playPauseButton.addEventListener('click', () => this.togglePlayPause());
      this.frame = this.frame.bind(this);
    }

    togglePlayPause() {
      this.isPlaying
        ? this.pause()
        : this.play();

      this.ui.playPauseButton.textContent = this.isPlaying ? 'Pause' : 'Play';
    }

    pause() {
      this.isPlaying = false;
    }

    play() {
      this.isPlaying = true;
      requestAnimationFrame(this.frame);
    }

    frame() {
      this.canvasManager.drawOnDragInterval();

      const matricesData = this.canvasManager.matrices.map(matrix => matrix.imageData);

      this.canvasManager.matrices.forEach((matrix, index) => {
        const transformationFunction = this.transformationManager.getTransformationFunction(index);
        const width = matrix.width;
        const height = matrix.height;
        const wrappedTransformationFunction = (x, y) => {
          try {
            return transformationFunction(x, y, width, height, matricesData);
          } catch (error) {
            this.ui.errorDisplay.textContent = `Erreur pendant l'ex√©cution : ${error.message}`;
            console.error("Erreur pendant l'ex√©cution : ", error);
            return { x, y };
          }
        };
        matrix.transform(wrappedTransformationFunction);
      });

      this.canvasManager.updateCanvas();

      if (this.isPlaying) {
        requestAnimationFrame(this.frame);
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const state = new State();
    const ui = new UI();
    const transformationManager = new TransformationManager(state, ui);
    const canvasManager = new CanvasManager(state, transformationManager, ui);
    new ControlPanel(canvasManager, transformationManager, ui);

    // Remplir la liste d√©roulante des transformations
    predefinedTransformations.forEach((transformation, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = transformation.name;
      ui.transformationSelector.appendChild(option);
    });

    // G√©rer la s√©lection d'une transformation
    ui.transformationSelector.addEventListener('change', (event) => {
      const selectedIndex = event.target.value;
      if (selectedIndex !== '') {
        const selectedTransformation = predefinedTransformations[selectedIndex];
        ui.transformationCodeInput.value = selectedTransformation.code;
        transformationManager.transformationCodeChanged(canvasManager.currentMatrixIndex);
      }
    });
  });
</script>
</body>
</html>
