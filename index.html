<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid black;
        }
        .controls {
            margin-top: 10px;
        }
        .matrix-selector { margin-top: 10px; }
        .resize-anchor {
            width: 10px;
            height: 10px;
            background-color: grey;
            position: absolute;
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
        }
        #eraserButton.active {
            background-color: #888;
            color: white;
        }
        #pointColor.disabled {
            background-image: linear-gradient(45deg, #888 25%, transparent 25%, transparent 50%, #888 50%, #888 75%, transparent 75%);
            background-size: 4px 4px;
            opacity: 0.5;
        }

    </style>
</head>
<body>
<h1>Canvas avec Transformation Param√©trable et Calque Sans Bord</h1>

<div class="canvas-container">
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <div class="resize-anchor" id="resizeAnchor"></div>
</div>

<div class="controls">
    <button id="clearButton">Effacer</button>
    <button id="clearAllButton">Tout effacer</button>
    <button id="addMatrixButton">Ajouter </button>
    <button id="removeMatrixButton">Supprimer </button>
    <select id="matrixSelector" class="matrix-selector"></select>
    <button id="playPauseButton">Play</button>
    <label for="pointSize">Taille du pinceau:</label>
    <input type="range" id="pointSize" min="5" max="50" value="15">
    <label for="pointColor">Couleur du pinceau:</label>
    <button id="eraserButton">üßΩ Gomme</button>
    <input type="color" id="pointColor" value="#ff0000">
    <label for="pointShape">Forme du pinceau:</label>
    <select id="pointShape">
        <option value="circle">Cercle</option>
        <option value="square">Carr√©</option>
        <option value="triangle">Triangle</option>
        <option value="segment">Segment</option>
    </select>
    <label for="drawOnDrag">Dessin continu</label>
    <input type="checkbox" id="drawOnDrag">
</div>

<textarea id="transformationCode" class="transformation-box" rows="4">
x = x + 1;
y = y + 1;
</textarea>

<script>
  class UI {
    constructor(){
      this.clearButton = document.getElementById('clearButton');
      this.clearAllButton = document.getElementById('clearAllButton');
      this.eraserButton = document.getElementById('eraserButton');
      this.pointColorInput = document.getElementById('pointColor');
      this.pointSizeInput = document.getElementById('pointSize');
      this.pointColorInput = document.getElementById('pointColor');
      this.pointShapeInput = document.getElementById('pointShape');
      this.drawOnDragCheckbox = document.getElementById('drawOnDrag');
      this.canvas = document.getElementById('myCanvas');
      this.resizeAnchor = document.getElementById("resizeAnchor");
      this.addMatrixButton = document.getElementById("addMatrixButton");
      this.removeMatrixButton = document.getElementById("removeMatrixButton");
      this.matrixSelector = document.getElementById("matrixSelector");
      this.transformationCodeInput = document.getElementById("transformationCode");
      this.playPauseButton = document.getElementById('playPauseButton');
    }
  }

  class State {
    constructor() {
      this.currentMatrixIndex = 0;
    }
  }
  
  class Matrix {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.offscreenCanvas = document.createElement('canvas');
      this.offscreenCanvas.width = width;
      this.offscreenCanvas.height = height;
      this.context = this.offscreenCanvas.getContext('2d');
      this.matrix = new Uint8ClampedArray(width * height * 4); // Stockage RGBA
    }

    transform(transformationFunction) {
      // Cr√©er un tableau pour stocker les donn√©es transform√©es
      const newMatrix = new Uint8ClampedArray(this.width * this.height * 4);

      // Appliquer la transformation pixel par pixel
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const index = (y * this.width + x) * 4;
          const { x: newX, y: newY } = transformationFunction(x, y);
          const wrappedX = ((newX % this.width) + this.width) % this.width;
          const wrappedY = ((newY % this.height) + this.height) % this.height;
          const newIndex = (wrappedY * this.width + wrappedX) * 4;

          // Copier les donn√©es de couleur dans la nouvelle position
          newMatrix[newIndex] = this.matrix[index];
          newMatrix[newIndex + 1] = this.matrix[index + 1];
          newMatrix[newIndex + 2] = this.matrix[index + 2];
          newMatrix[newIndex + 3] = this.matrix[index + 3];
        }
      }

      // Mettre √† jour la matrice actuelle
      this.matrix.set(newMatrix);

      // Cr√©er et dessiner sur l'`offscreenCanvas`
      const imageData = new ImageData(this.matrix, this.width, this.height);

      this.context.putImageData(imageData, 0, 0);
    }


    drawToMainCanvas(mainContext) {
      mainContext.drawImage(this.offscreenCanvas, 0, 0); // Assurez-vous que cette ligne est ex√©cut√©e
    }

    clear() {
      this.matrix.fill(0);
    }

    hexToRGBA(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255,
        a: 255 // Opacit√© compl√®te
      };
    }

    paint(x, y, brush) {
      const isEraser = brush.pointColor === null;
      const color = isEraser
        ? { r: 0, g: 0, b: 0, a: 0 }  // Couleur transparente pour la gomme
        : this.hexToRGBA(brush.pointColor);

      const halfSize = Math.floor(brush.pointSize / 2);

      // Utilise la forme du pinceau s√©lectionn√©e
      if (brush.pointShape === 'segment' && brush.endX !== undefined && brush.endY !== undefined) {
        this.paintSegment(x, y, brush.endX, brush.endY, color, brush.pointSize);
      } else if (brush.pointShape === 'circle') {
        this.paintCircle(x, y, halfSize, color);
      } else if (brush.pointShape === 'square') {
        this.paintSquare(x, y, halfSize, color);
      } else if (brush.pointShape === 'triangle') {
        this.paintTriangle(x, y, halfSize, color);
      }
    }

    paintCircle(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          if (Math.sqrt(offsetX ** 2 + offsetY ** 2) <= halfSize) {
            this.setPixelColor(x + offsetX, y + offsetY, color);
          }
        }
      }
    }

    paintSquare(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          this.setPixelColor(x + offsetX, y + offsetY, color);
        }
      }
    }

    paintTriangle(x, y, halfSize, color) {
      for (let offsetY = 0; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -offsetY; offsetX <= offsetY; offsetX++) {
          this.setPixelColor(x + offsetX, y - offsetY + halfSize, color);
        }
      }
    }

    paintSegment(x1, y1, x2, y2, color, brushSize) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = x1 < x2 ? 1 : -1;
      const sy = y1 < y2 ? 1 : -1;
      let err = dx - dy;
      const halfSize = Math.floor(brushSize / 2);

      while (true) {
        for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
          for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
            this.setPixelColor(x1 + offsetX, y1 + offsetY, color);
          }
        }
        if (x1 === x2 && y1 === y2) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    wrapCoordinate(value, max) {
      return ((value % max) + max) % max;
    }

    setPixelColor(rawX, rawY, color) {
      const x = this.wrapCoordinate(rawX, this.width);
      const y = this.wrapCoordinate(rawY, this.height);
      const index = (y * this.width + x) * 4;
      this.matrix[index] = color.r;
      this.matrix[index + 1] = color.g;
      this.matrix[index + 2] = color.b;
      this.matrix[index + 3] = color.a;
    }

    resize(width, height) {
      const newMatrix = new Uint8ClampedArray(width * height * 4);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const oldX = x % this.width;
          const oldY = y % this.height;
          const newIndex = (y * width + x) * 4;
          const oldIndex = (oldY * this.width + oldX) * 4;
          newMatrix.set(this.matrix.slice(oldIndex, oldIndex + 4), newIndex);
        }
      }
      this.width = width;
      this.height = height;
      this.matrix = newMatrix;
    }
  }

  class CanvasManager {
    constructor(state, transformationManager, ui) {
      this.state = state;
      this.ui = ui;
      this.context = this.ui.canvas.getContext('2d');
      this.transformationManager = transformationManager;

      this.imageData = this.context.createImageData(this.ui.canvas.width, this.ui.canvas.height);
      this.brush = { pointSize: 15, pointColor: '#ff0000', pointShape: 'circle' };
      this.isDrawing = false;
      this.startPoint = null;
      this.matrices = [];

      this.initializeControls();
      this.updateMatrixSelector();

      this.addNewMatrix();
    }

    get currentMatrixIndex() {
      return this.state.currentMatrixIndex;
    }

    set currentMatrixIndex(index) {
      this.state.currentMatrixIndex = index;
    }

    addNewMatrix(matrice = null) {
      const newMatrix = matrice || new Matrix(this.ui.canvas.width, this.ui.canvas.height);
      this.matrices.push(newMatrix);
      this.currentMatrixIndex = this.matrices.length - 1;

      // Initialiser la fonction de transformation pour le nouveau calque
      const initialCode = this.transformationManager.getCode(this.currentMatrixIndex);
      this.transformationManager.transformationCodeChanged(this.currentMatrixIndex, initialCode);

      this.updateMatrixSelector();
      this.updateCanvas();
    }

    initializeControls() {
      this.initClearButton();
      this.initClearAllButton();
      this.initEraserButton();
      this.initBrushSettings();
      this.initDrawOnDragCheckbox();
      this.initCanvasMouseEvents();
      this.initResize();
      this.initMatrixControls();
    }

    get currentMatrix() {
      return this.matrices[this.currentMatrixIndex];
    }

    initClearButton() {
      this.ui.clearButton.addEventListener('click', () => this.clearCurrentMatrix());
    }

    initClearAllButton() {
      this.ui.clearAllButton.addEventListener('click', () => this.clearAllMatrices());
    }

    initEraserButton() {
      this.ui.eraserButton.addEventListener('click', () => {
        const isEraserActive = this.ui.eraserButton.classList.toggle("active");
        this.brush.pointColor = isEraserActive ? null : this.ui.pointColorInput.value;
        this.ui.pointColorInput.classList.toggle("disabled", isEraserActive);
      });

      // D√©sactive la gomme en r√©tablissant la couleur lorsque l‚Äôutilisateur clique sur le s√©lecteur de couleur
      this.ui.pointColorInput.addEventListener('click', () => {
        this.ui.eraserButton.classList.remove("active");
        this.ui.pointColorInput.classList.remove("disabled");
        this.brush.pointColor = this.ui.pointColorInput.value; // R√©tablit la couleur
      });
    }

    initBrushSettings() {
      this.ui.pointSizeInput.addEventListener('input', () => {
        this.brush.pointSize = parseInt(this.ui.pointSizeInput.value, 10);
      });

      this.ui.pointColorInput.addEventListener('input', () => {
        this.brush.pointColor = this.ui.pointColorInput.value;
      });

      this.ui.pointShapeInput.addEventListener('change', () => {
        this.brush.pointShape = this.ui.pointShapeInput.value;
      });
    }

    initDrawOnDragCheckbox() {
      this.ui.drawOnDragCheckbox.addEventListener('change', () => {
        this.drawOnDrag = this.ui.drawOnDragCheckbox.checked;
      });
    }

    initCanvasMouseEvents() {
      this.ui.canvas.addEventListener('mousedown', (event) => this.handleMouseDown(event));

      this.ui.canvas.addEventListener('mousemove', (event) => {
        if (this.isDrawing && this.drawOnDrag && this.brush.pointShape !== 'segment') {
          const rect = this.ui.canvas.getBoundingClientRect();
          const x = Math.floor(event.clientX - rect.left);
          const y = Math.floor(event.clientY - rect.top);
          this.lastMousePosition = { x, y };
          this.drawAt(x, y);
        }
      });

      this.ui.canvas.addEventListener('mouseup', (event) => {
        if (this.isDrawing && this.brush.pointShape === 'segment' && this.startPoint) {
          const rect = this.ui.canvas.getBoundingClientRect();
          const x = Math.floor(event.clientX - rect.left);
          const y = Math.floor(event.clientY - rect.top);
          this.currentMatrix.paint(this.startPoint.x, this.startPoint.y, {
            ...this.brush, endX: x, endY: y
          });
          this.startPoint = null;
        }
        this.isDrawing = false;
        this.updateCanvas();
      });
    }

    initResize() {
      const addListeners = () => {
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", removeListeners);
      }
      const removeListeners = () => {
        document.removeEventListener("mousemove", mouseMove);
        document.removeEventListener("mouseup", removeListeners);
      }
      const mouseMove = (event) => {
        const newWidth = Math.ceil(event.clientX - this.ui.canvas.getBoundingClientRect().left);
        const newHeight = Math.ceil(event.clientY - this.ui.canvas.getBoundingClientRect().top);
        this.resizeCanvas(newWidth, newHeight);
      }

      this.ui.resizeAnchor.addEventListener("mousedown", addListeners);
    }

    initMatrixControls() {
      this.ui.addMatrixButton.addEventListener("click", () => this.addNewMatrix());

      this.ui.removeMatrixButton.addEventListener("click", () => {
        if (this.matrices.length > 1) {
          this.matrices.splice(this.currentMatrixIndex, 1);
          this.currentMatrixIndex = Math.max(0, this.currentMatrixIndex - 1);
          this.updateMatrixSelector();
          this.updateCanvas();
        }
      });

      this.ui.matrixSelector.addEventListener("change", (event) => {
        this.currentMatrixIndex = parseInt(event.target.value, 10);
        this.updateCanvas();
        this.updateTransformationCodeInput();
      });
    }

    handleMouseDown(event) {
      const rect = this.ui.canvas.getBoundingClientRect();
      const x = Math.floor(event.clientX - rect.left);
      const y = Math.floor(event.clientY - rect.top);
      this.isDrawing = true;
      this.lastMousePosition = { x, y };
      if (this.brush.pointShape === 'segment') {
        this.startPoint = { x, y }; // Enregistrer le point de d√©part
      } else {
        this.drawAt(x, y);
      }

      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    }

    handleMouseMove = (event) => {
      if (this.isDrawing && this.drawOnDrag && this.brush.pointShape !== 'segment') {
        const rect = this.ui.canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - rect.left);
        const y = Math.floor(event.clientY - rect.top);
        this.drawAt(x, y);
      }
    }

    handleMouseUp = (event) => {
      if (this.isDrawing && this.brush.pointShape === 'segment' && this.startPoint) {
        const rect = this.ui.canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - rect.left);
        const y = Math.floor(event.clientY - rect.top);
        this.currentMatrix.paint(this.startPoint.x, this.startPoint.y, {
          ...this.brush, endX: x, endY: y
        });
        this.startPoint = null;
      }
      this.isDrawing = false;
      this.updateCanvas();

      // Supprimer les √©couteurs globaux
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    clearCurrentMatrix() {
      this.currentMatrix.clear();
      this.updateCanvas();
    }

    clearAllMatrices() {
      this.matrices.forEach(matrix => matrix.clear());
      this.updateCanvas();
    }

    resizeCanvas(newWidth, newHeight) {
      // Redimensionner le canevas
      this.ui.canvas.width = newWidth;
      this.ui.canvas.height = newHeight;

      // Redimensionner la matrice courante
      this.currentMatrix.resize(newWidth, newHeight);

      // Cr√©er de nouveaux `imageData` bas√©s sur la nouvelle taille du canevas
      this.imageData = this.context.createImageData(newWidth, newHeight);

      // Mettre √† jour le canevas avec les nouvelles dimensions et les donn√©es de la matrice
      this.updateCanvas();
    }

    drawAt(x, y) {
      this.currentMatrix.paint(x, y, this.brush);
      this.updateCanvas();
    }

    updateCanvas() {
      // Efface le contenu existant du canevas principal
      this.context.clearRect(0, 0, this.ui.canvas.width, this.ui.canvas.height);

      // Dessine chaque calque sur le canevas principal
      this.matrices.forEach(matrix => {
        matrix.drawToMainCanvas(this.context);
      });
    }


    updateMatrixSelector() {
      this.ui.matrixSelector.innerHTML = '';
      this.matrices.forEach((_, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = `Calque ${index + 1}`;
          if (index === this.currentMatrixIndex) option.selected = true;
          this.ui.matrixSelector.appendChild(option);
        });

      this.updateTransformationCodeInput();
    }

    drawOnDragInterval() {
      if (this.lastMousePosition) {
        const { x, y } = this.lastMousePosition;
        this.currentMatrix.paint(x, y, this.brush);
      }
    }

    updateTransformationCodeInput() {
      this.ui.transformationCodeInput.value = this.transformationManager.getCode(this.currentMatrixIndex);
    }
  }

  class TransformationManager {
    constructor(state, ui) {
      this.state = state;
      this.ui = ui;
      this.transformationFunctions = {}; // Stocke les fonctions de transformation par matrice
      this.codes = {}; // Stocke le code de transformation par matrice
      this.ui.transformationCodeInput.addEventListener('blur', () => this.transformationCodeChanged(this.state.currentMatrixIndex));
    }

    transformationCodeChanged(matrixIndex, code = this.ui.transformationCodeInput.value) {
      this.codes[matrixIndex] = code;
      this.createTransformationFunction(matrixIndex, code);
    }

    getCode(matrixIndex) {
      return this.codes[matrixIndex] || 'x = x + 1;\ny = y + 1;';
    }

    createTransformationFunction(matrixIndex, code) {
      try {
        this.transformationFunctions[matrixIndex] = new Function('x', 'y', `${code} return { x, y };`);
      } catch (error) {
        console.error("Erreur dans la fonction de transformation : ", error);
      }
    }

    getTransformationFunction(matrixIndex) {
      return this.transformationFunctions[matrixIndex] || ((x, y) => ({ x, y }));
    }

    applyTransformation(matrix, transformationFunction) {
      const newMatrix = new Uint8ClampedArray(matrix.width * matrix.height * 4);
      for (let y = 0; y < matrix.height; y++) {
        for (let x = 0; x < matrix.width; x++) {
          const { x: newX, y: newY } = transformationFunction(x, y);
          const targetX = (newX + matrix.width) % matrix.width;
          const targetY = (newY + matrix.height) % matrix.height;
          const newIndex = (targetY * matrix.width + targetX) * 4;
          const oldIndex = (y * matrix.width + x) * 4;

          // Copier uniquement si le pixel n'est pas transparent
          if (matrix.matrix[oldIndex + 3] !== 0) {
            newMatrix.set(matrix.matrix.slice(oldIndex, oldIndex + 4), newIndex);
          }
        }
      }
      matrix.matrix = newMatrix;
    }

  }

  class ControlPanel {
    constructor(canvasManager, transformationManager, ui) {
      this.canvasManager = canvasManager;
      this.transformationManager = transformationManager;
      this.ui = ui;

      this.isPlaying = false;
      this.intervalId = null;

      this.ui.playPauseButton.addEventListener('click', () => this.togglePlayPause());
    }

    togglePlayPause() {
      this.isPlaying
        ? this.pause()
        : this.play();

      this.ui.playPauseButton.textContent = this.isPlaying ? 'Pause' : 'Play';
    }

    pause(){
      this.isPlaying = false;
    }

    play() {
      this.isPlaying = true;

      const frame = () => {
        console.log("frame");
        // to factorize
        this.canvasManager.matrices.forEach((matrix, index) => {
          const transformationFunction = this.transformationManager.getTransformationFunction(index);
          matrix.transform(transformationFunction);
        });
        this.canvasManager.updateCanvas(); // Met √† jour le canvas apr√®s chaque transformation
        if (this.isPlaying) {
          requestAnimationFrame(frame);
        }
      };

      requestAnimationFrame(frame); // Lancement de l'animation en continu
    }


  }

  document.addEventListener('DOMContentLoaded', () => {
    const state = new State();
    const ui = new UI();
    const transformationManager = new TransformationManager(state, ui);
    const canvasManager = new CanvasManager(state, transformationManager, ui);
    new ControlPanel(canvasManager, transformationManager, ui);
  });
</script>
</body>
</html>
