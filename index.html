<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid black;
        }
        .controls {
            margin-top: 10px;
        }
        .matrix-selector { margin-top: 10px; }
        .resize-anchor {
            width: 10px;
            height: 10px;
            background-color: grey;
            position: absolute;
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
        }
        #eraserButton.active {
            background-color: #888;
            color: white;
        }
        #pointColor.disabled {
            background-image: linear-gradient(45deg, #888 25%, transparent 25%, transparent 50%, #888 50%, #888 75%, transparent 75%);
            background-size: 4px 4px;
            opacity: 0.5;
        }

    </style>
</head>
<body>
<h1>Canvas avec Transformation Param√©trable et Calque Sans Bord</h1>

<div class="canvas-container">
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <div class="resize-anchor" id="resizeAnchor"></div>
</div>

<div class="controls">
    <button id="clearButton">Effacer</button>
    <button id="addMatrixButton">Ajouter </button>
    <button id="removeMatrixButton">Supprimer </button>
    <select id="matrixSelector" class="matrix-selector"></select>
    <button id="playPauseButton">Play</button>
    <label for="pointSize">Taille du pinceau:</label>
    <input type="range" id="pointSize" min="5" max="50" value="15">
    <label for="pointColor">Couleur du pinceau:</label>
    <button id="eraserButton">üßΩ Gomme</button>
    <input type="color" id="pointColor" value="#ff0000">
    <label for="pointShape">Forme du pinceau:</label>
    <select id="pointShape">
        <option value="circle">Cercle</option>
        <option value="square">Carr√©</option>
        <option value="triangle">Triangle</option>
        <option value="segment">Segment</option>
    </select>
    <label for="intervalSpeed">Vitesse (IPS):</label>
    <input type="range" id="intervalSpeed" min="0.1" max="100" step="0.1" value="25">
    <span id="intervalSpeedValue">25 IPS</span>
    <label for="drawOnDrag">Dessin continu</label>
    <input type="checkbox" id="drawOnDrag">
</div>

<textarea id="transformationCode" class="transformation-box" rows="4">
x = x + 1;
y = y + 1;
</textarea>

<script>
  class Grid {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.matrix = new Uint8ClampedArray(width * height * 4); // Stockage RGBA pour chaque pixel
    }

    clear() {
      this.matrix.fill(0);
    }

    hexToRGBA(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255,
        a: 255 // Opacit√© compl√®te
      };
    }

    wrapCoordinate(value, max) {
      return ((value % max) + max) % max;
    }

    updateMatrix(x, y, brushSettings) {
      const isEraser = brushSettings.pointColor === null;
      const color = isEraser
        ? { r: 0, g: 0, b: 0, a: 0 }  // Couleur transparente pour la gomme
        : this.hexToRGBA(brushSettings.pointColor);

      const halfSize = Math.floor(brushSettings.pointSize / 2);

      // Utilise la forme du pinceau s√©lectionn√©e
      if (brushSettings.pointShape === 'segment' && brushSettings.endX !== undefined && brushSettings.endY !== undefined) {
        this.paintSegment(x, y, brushSettings.endX, brushSettings.endY, color, brushSettings.pointSize);
      } else if (brushSettings.pointShape === 'circle') {
        this.paintCircle(x, y, halfSize, color);
      } else if (brushSettings.pointShape === 'square') {
        this.paintSquare(x, y, halfSize, color);
      } else if (brushSettings.pointShape === 'triangle') {
        this.paintTriangle(x, y, halfSize, color);
      }
    }

    paintCircle(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          if (Math.sqrt(offsetX ** 2 + offsetY ** 2) <= halfSize) {
            this.setPixelColor(x + offsetX, y + offsetY, color);
          }
        }
      }
    }

    paintSquare(x, y, halfSize, color) {
      for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
          this.setPixelColor(x + offsetX, y + offsetY, color);
        }
      }
    }

    paintTriangle(x, y, halfSize, color) {
      for (let offsetY = 0; offsetY <= halfSize; offsetY++) {
        for (let offsetX = -offsetY; offsetX <= offsetY; offsetX++) {
          this.setPixelColor(x + offsetX, y - offsetY + halfSize, color);
        }
      }
    }

    paintSegment(x1, y1, x2, y2, color, brushSize) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = x1 < x2 ? 1 : -1;
      const sy = y1 < y2 ? 1 : -1;
      let err = dx - dy;
      const halfSize = Math.floor(brushSize / 2);

      while (true) {
        for (let offsetY = -halfSize; offsetY <= halfSize; offsetY++) {
          for (let offsetX = -halfSize; offsetX <= halfSize; offsetX++) {
            this.setPixelColor(x1 + offsetX, y1 + offsetY, color);
          }
        }
        if (x1 === x2 && y1 === y2) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    setPixelColor(x, y, color) {
      const wrappedX = this.wrapCoordinate(x, this.width);
      const wrappedY = this.wrapCoordinate(y, this.height);
      const index = (wrappedY * this.width + wrappedX) * 4;
      this.matrix[index] = color.r;
      this.matrix[index + 1] = color.g;
      this.matrix[index + 2] = color.b;
      this.matrix[index + 3] = color.a;
    }

    resize(width, height) {
      const newMatrix = new Uint8ClampedArray(width * height * 4);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const oldX = x % this.width;
          const oldY = y % this.height;
          const newIndex = (y * width + x) * 4;
          const oldIndex = (oldY * this.width + oldX) * 4;
          newMatrix.set(this.matrix.slice(oldIndex, oldIndex + 4), newIndex);
        }
      }
      this.width = width;
      this.height = height;
      this.matrix = newMatrix;
    }
  }

  class CanvasManager {
    constructor(canvas, transformationManager) {
      this.canvas = canvas;
      this.context = canvas.getContext('2d');
      this.transformationManager = transformationManager;
      this.imageData = this.context.createImageData(canvas.width, canvas.height);
      this.brushSettings = { pointSize: 15, pointColor: '#ff0000', pointShape: 'circle' };
      this.isDrawing = false;
      this.startPoint = null;
      this.matrices = [];
      this.currentMatrixIndex = 0;

      this.initializeControls();
      this.updateMatrixSelector();

      this.addNewMatrix();
    }

    addNewMatrix(matrice = null) {
      const newMatrix = matrice || new Grid(this.canvas.width, this.canvas.height);
      this.matrices.push(newMatrix);
      this.currentMatrixIndex = this.matrices.length - 1;

      // Initialiser la fonction de transformation pour le nouveau calque
      const initialCode = this.transformationManager.getCode(this.currentMatrixIndex);
      this.transformationManager.saveTransformationCode(this.currentMatrixIndex, initialCode);

      this.updateMatrixSelector();
      this.updateCanvas();
    }

    initializeControls() {
      this.initClearButton();
      this.initEraserButton();
      this.initBrushSettings();
      this.initDrawOnDragCheckbox();
      this.initCanvasMouseEvents();
      this.initializeResize();
      this.initMatrixControls();
    }

    get currentMatrix() {
      return this.matrices[this.currentMatrixIndex];
    }

    initClearButton() {
      const clearButton = document.getElementById('clearButton');
      clearButton.addEventListener('click', () => this.clearCanvas());
    }

    initEraserButton() {
      const eraserButton = document.getElementById('eraserButton');
      const pointColorInput = document.getElementById('pointColor');

      eraserButton.addEventListener('click', () => {
        const isEraserActive = eraserButton.classList.toggle("active");
        this.brushSettings.pointColor = isEraserActive ? null : pointColorInput.value; // Null si gomme active, sinon couleur
        pointColorInput.classList.toggle("disabled", isEraserActive); // Barre la couleur si gomme active
      });

      // D√©sactive la gomme en r√©tablissant la couleur lorsque l‚Äôutilisateur clique sur le s√©lecteur de couleur
      pointColorInput.addEventListener('click', () => {
        eraserButton.classList.remove("active");
        pointColorInput.classList.remove("disabled");
        this.brushSettings.pointColor = pointColorInput.value; // R√©tablit la couleur
      });
    }

    initBrushSettings() {
      const pointSizeInput = document.getElementById('pointSize');
      const pointColorInput = document.getElementById('pointColor');
      const pointShapeInput = document.getElementById('pointShape');

      pointSizeInput.addEventListener('input', () => {
        this.brushSettings.pointSize = parseInt(pointSizeInput.value, 10);
      });

      pointColorInput.addEventListener('input', () => {
        this.brushSettings.pointColor = pointColorInput.value;
      });

      pointShapeInput.addEventListener('change', () => {
        this.brushSettings.pointShape = pointShapeInput.value;
      });
    }

    initDrawOnDragCheckbox() {
      const drawOnDragCheckbox = document.getElementById('drawOnDrag');
      drawOnDragCheckbox.addEventListener('change', () => {
        this.drawOnDrag = drawOnDragCheckbox.checked;
      });
    }

    initCanvasMouseEvents() {
      this.canvas.addEventListener('mousedown', (event) => this.handleMouseDown(event));

      this.canvas.addEventListener('mousemove', (event) => {
        if (this.isDrawing && this.drawOnDrag && this.brushSettings.pointShape !== 'segment') {
          const rect = this.canvas.getBoundingClientRect();
          const x = Math.floor(event.clientX - rect.left);
          const y = Math.floor(event.clientY - rect.top);
          this.lastMousePosition = { x, y };
          this.drawAt(x, y);
        }
      });

      this.canvas.addEventListener('mouseup', (event) => {
        if (this.isDrawing && this.brushSettings.pointShape === 'segment' && this.startPoint) {
          const rect = this.canvas.getBoundingClientRect();
          const x = Math.floor(event.clientX - rect.left);
          const y = Math.floor(event.clientY - rect.top);
          this.currentMatrix.updateMatrix(this.startPoint.x, this.startPoint.y, {
            ...this.brushSettings, endX: x, endY: y
          });
          this.startPoint = null;
        }
        this.isDrawing = false;
        this.updateCanvas();
      });
    }

    initializeResize() {
      const resizeAnchor = document.getElementById("resizeAnchor");
      let isResizing = false;

      resizeAnchor.addEventListener("mousedown", (event) => {
        isResizing = true;
        event.preventDefault();
      });

      document.addEventListener("mousemove", (event) => {
        if (isResizing) {
          const newWidth = event.clientX - this.canvas.getBoundingClientRect().left;
          const newHeight = event.clientY - this.canvas.getBoundingClientRect().top;
          this.resizeCanvas(newWidth, newHeight);
        }
      });

      document.addEventListener("mouseup", () => {
        isResizing = false;
      });
    }

    initMatrixControls() {
      const addMatrixButton = document.getElementById("addMatrixButton");
      const removeMatrixButton = document.getElementById("removeMatrixButton");
      const matrixSelector = document.getElementById("matrixSelector");

      addMatrixButton.addEventListener("click", () => this.addNewMatrix());

      removeMatrixButton.addEventListener("click", () => {
        if (this.matrices.length > 1) {
          this.matrices.splice(this.currentMatrixIndex, 1);
          this.currentMatrixIndex = Math.max(0, this.currentMatrixIndex - 1);
          this.updateMatrixSelector();
          this.updateCanvas();
        }
      });

      matrixSelector.addEventListener("change", (event) => {
        this.currentMatrixIndex = parseInt(event.target.value, 10);
        this.updateCanvas();
        this.updateTransformationCode();
      });
    }

    handleMouseDown(event) {
      const rect = this.canvas.getBoundingClientRect();
      const x = Math.floor(event.clientX - rect.left);
      const y = Math.floor(event.clientY - rect.top);
      this.isDrawing = true;
      this.lastMousePosition = { x, y };
      if (this.brushSettings.pointShape === 'segment') {
        this.startPoint = { x, y }; // Enregistrer le point de d√©part
      } else {
        this.drawAt(x, y);
      }

      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    }

    handleMouseMove = (event) => {
      if (this.isDrawing && this.drawOnDrag && this.brushSettings.pointShape !== 'segment') {
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - rect.left);
        const y = Math.floor(event.clientY - rect.top);
        this.drawAt(x, y);
      }
    }

    handleMouseUp = (event) => {
      if (this.isDrawing && this.brushSettings.pointShape === 'segment' && this.startPoint) {
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - rect.left);
        const y = Math.floor(event.clientY - rect.top);
        this.currentMatrix.updateMatrix(this.startPoint.x, this.startPoint.y, {
          ...this.brushSettings, endX: x, endY: y
        });
        this.startPoint = null;
      }
      this.isDrawing = false;
      this.updateCanvas();

      // Supprimer les √©couteurs globaux
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    clearCanvas() {
      this.currentMatrix.clear();
      this.updateCanvas();
    }

    resizeCanvas(newWidth, newHeight) {
      this.canvas.width = newWidth;
      this.canvas.height = newHeight;
      this.currentMatrix.resize(newWidth, newHeight);
      this.imageData = this.context.createImageData(this.currentMatrix.width, this.currentMatrix.height);
      this.updateCanvas();
    }

    drawAt(x, y) {
      this.currentMatrix.updateMatrix(x, y, this.brushSettings);
      this.updateCanvas();
    }

    updateCanvas() {
      this.imageData.data.fill(0);

      for (const matrix of this.matrices) {
        for (let i = 0; i < matrix.matrix.length; i += 4) {
          if (matrix.matrix[i + 3] !== 0) { // Canaux RGBA, [i+3] est l'alpha
            this.imageData.data[i] = matrix.matrix[i];       // Rouge
            this.imageData.data[i + 1] = matrix.matrix[i + 1]; // Vert
            this.imageData.data[i + 2] = matrix.matrix[i + 2]; // Bleu
            this.imageData.data[i + 3] = matrix.matrix[i + 3]; // Alpha
          }
        }
      }

      // Applique les donn√©es de l'imageData sur le canvas
      this.context.putImageData(this.imageData, 0, 0);
    }

    updateMatrixSelector() {
      const matrixSelector = document.getElementById("matrixSelector");
      matrixSelector.innerHTML = '';
      this.matrices.forEach((_, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = `Calque ${index + 1}`;
          if (index === this.currentMatrixIndex) option.selected = true;
          matrixSelector.appendChild(option);
        });

      document.getElementById("transformationCode").value =
        this.transformationManager.getCode(this.currentMatrixIndex);
    }

    drawOnDragInterval() {
      if (this.lastMousePosition) {
        const { x, y } = this.lastMousePosition;
        this.currentMatrix.updateMatrix(x, y, this.brushSettings);
      }
    }

    updateTransformationCode() {
      const code = this.transformationManager.getCode(this.currentMatrixIndex);
      document.getElementById("transformationCode").value = code;
    }
  }

  class TransformationManager {
    constructor(transformationCodeElement) {
      this.transformationCodeElement = transformationCodeElement;
      this.transformationFunctions = {}; // Stocke les fonctions de transformation par matrice
      this.codes = {}; // Stocke le code de transformation par matrice
      transformationCodeElement.addEventListener('blur', () => this.saveTransformationCode());
    }

    saveTransformationCode(matrixIndex, code = this.transformationCodeElement.value) {
      this.codes[matrixIndex] = code;
      this.createTransformationFunction(matrixIndex, code);
    }

    getCode(matrixIndex) {
      return this.codes[matrixIndex] || 'x = x + 1;\ny = y + 1;';
    }

    createTransformationFunction(matrixIndex, code) {
      try {
        this.transformationFunctions[matrixIndex] = new Function('x', 'y', `${code} return { x, y };`);
      } catch (error) {
        console.error("Erreur dans la fonction de transformation : ", error);
      }
    }

    getTransformationFunction(matrixIndex) {
      return this.transformationFunctions[matrixIndex] || ((x, y) => ({ x, y }));
    }

    applyTransformation(grid, transformationFunction) {
      const newMatrix = new Uint8ClampedArray(grid.width * grid.height * 4);
      for (let y = 0; y < grid.height; y++) {
        for (let x = 0; x < grid.width; x++) {
          const { x: newX, y: newY } = transformationFunction(x, y);
          const targetX = (newX + grid.width) % grid.width;
          const targetY = (newY + grid.height) % grid.height;
          const newIndex = (targetY * grid.width + targetX) * 4;
          const oldIndex = (y * grid.width + x) * 4;
          newMatrix.set(grid.matrix.slice(oldIndex, oldIndex + 4), newIndex);
        }
      }
      grid.matrix = newMatrix;
    }
  }

  class ControlPanel {
    constructor(canvasManager, transformationManager, playPauseButtonId, intervalSpeedInputId, intervalSpeedValueId) {
      this.canvasManager = canvasManager;
      this.transformationManager = transformationManager;
      this.playPauseButton = document.getElementById(playPauseButtonId);
      this.intervalSpeedInput = document.getElementById(intervalSpeedInputId);
      this.intervalSpeedValue = document.getElementById(intervalSpeedValueId);
      this.isPlaying = false;
      this.intervalId = null;

      this.playPauseButton.addEventListener('click', () => this.togglePlayPause());
      this.intervalSpeedInput.addEventListener('input', () => this.updateIntervalSpeed());

      this.updateIntervalSpeed();
    }

    updateIntervalSpeed() {
      const ips = parseFloat(this.intervalSpeedInput.value);
      this.intervalMs = 1000 / ips;
      this.intervalSpeedValue.textContent = `${ips.toFixed(1)} IPS`;

      if (this.isPlaying) {
        clearInterval(this.intervalId);
        this.startInterval();
      }
    }

    togglePlayPause() {
      this.isPlaying
        ? clearInterval(this.intervalId)
        : this.startInterval();

      this.isPlaying = !this.isPlaying;
      this.playPauseButton.textContent = this.isPlaying ? 'Pause' : 'Play';
    }

    startInterval() {
      this.intervalId = setInterval(() => {
        this.canvasManager.matrices.forEach((matrix, index) => {
          const transformationFunction = this.transformationManager.getTransformationFunction(index);
          this.transformationManager.applyTransformation(matrix, transformationFunction);
        });

        if (this.canvasManager.drawOnDrag && this.canvasManager.isDrawing) {
          this.canvasManager.drawOnDragInterval();
        }

        this.canvasManager.updateCanvas();
      }, this.intervalMs);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('myCanvas');
    const transformationManager = new TransformationManager(document.getElementById('transformationCode'));
    const canvasManager = new CanvasManager(canvas, transformationManager);
    new ControlPanel(canvasManager, transformationManager, 'playPauseButton', 'intervalSpeed', 'intervalSpeedValue');
  });
</script>
</body>
</html>
